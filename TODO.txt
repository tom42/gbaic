* console.hpp
  * Unit tests: do they now pollute the console? If so, fix them.
* Final test with shrinkler: dump output data and compare with the stored file from shrinkler-arm repo
  * Well perhaps make that a unit test???
* Get release build(s) to work
* Get it to compile with MSVC x64
* OK, back to shrinkler first:
  * We can successfully load ELF files (one particular anyway)
    * Now we must compress that using shrinkler data compression
* Need a break from shrinkler:
  * Wrap up input file loading:
    * Optional flat binary loading (with the option to specify load address and entry point!)
      * Already implement the command line options
      * They are file format independent, so we just do:
        * Load file
        * If options override entry, set it on the input file
        * If options override load address, set it on the input file
    * Remaining sanity checks. Either:
      * Implement them
      * Defer them
      * Discard them
  * We might want to support binary as input file format, but probably this should be opt-in.
    * This means we expect ELF by default and fail if input file is not ELF.
    * Only load file as binary if requested to do so.
* Prepare shrinkler:
  * OK: wrap shrinkler source into a library: we simply need it to do in memory compression of data files, I guess
    * How to we manage compiler flags? Shrinkler won't compile warning-free withour settings I am afraid
  * Put it into 3rdparty/shrinkler (orly? Perhaps we give it a top level directory since we are going to heavily hack it)
    * Try to create a header only library for it
    * Is it going to get any tests?
    * How MUCH are we going to hack it? I'd really not want it to call printf and exit all over the place
  * Only include the packer sources
  * Include shrinkler's LICENSE.txt!
  * Include a README.md stating CLEARLY that this is NOT the original shrinkler
* Stop using submodules?
  * Just for real 3rd party modules. Keep it for our own, e.g. argp-standalone
  * Or use subtree everywhere:
    * Delete the cxxopts submodule
    * Add shrinkler as subtree
    * Add argp-standalone as subtree
* Design input file loading
  * Binary files, with an assumed load address of IWRAM (do we allow overriding this?)
  * Elf files, which we convert to raw binary and whose load address we determine from the entry point
* Remove cxxopts (including the submodule)
* Check: does our argp.h supersede system argp?
* Update copyright notice (Copyright (c) 2020 Thomas Mathys => 2020, 2021)
* For deploying windows binaries, do we need to take care to distribute runtime libraries? Or do we link statically?
* Eventually, get rid of the fmt library (yeah, right)
