* Let's tackle those conversion problems in our own code
  * Let's see what we need
    * input_file.cpp: unsigned long long to size_t. Damit: that's uint64_t to uint32_t
* Stop using submodules?
  * Use subtree everywhere:
    * Delete the cxxopts submodule
    * Add shrinkler as subtree
    * Add argp-standalone as subtree
* Test debug/release build with
  * gcc 64
  * gcc 32
  * clang?
* Need a break from shrinkler:
  * Wrap up input file loading:
    * Optional flat binary loading (with the option to specify load address and entry point!)
      * Already implement the command line options
      * They are file format independent, so we just do:
        * Load file
        * If options override entry, set it on the input file
        * If options override load address, set it on the input file
    * Remaining sanity checks. Either:
      * Implement them
      * Defer them
      * Discard them
  * We might want to support binary as input file format, but probably this should be opt-in.
    * This means we expect ELF by default and fail if input file is not ELF.
    * Only load file as binary if requested to do so.
* Prepare shrinkler:
  * Put it into 3rdparty/shrinkler (orly? Perhaps we give it a top level directory since we are going to heavily hack it)
    * Is it going to get any tests?
  * Only include the packer sources
  * Include shrinkler's LICENSE.txt!
  * Include a README.md stating CLEARLY that this is NOT the original shrinkler
* Design input file loading
  * Binary files, with an assumed load address of IWRAM (do we allow overriding this?)
  * Elf files, which we convert to raw binary and whose load address we determine from the entry point
* Remove cxxopts (including the submodule)
* Check: does our argp.h supersede system argp?
* Update copyright notice (Copyright (c) 2020 Thomas Mathys => 2020, 2021)
* For deploying windows binaries, do we need to take care to distribute runtime libraries? Or do we link statically?
* Eventually, get rid of the fmt library (yeah, right)
