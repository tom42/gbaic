* Let's tackle those conversion problems in our own code
  * I would not like to use boost for this, since so far I've managed to keep it out of production code
  * Let's see what we need
    * input_file.cpp: unsigned long long to size_t. Damit: that's uint64_t to uint32_t
    * shrinkler.cpp:  casts from size_t to int.
    * So that's only two, fairly manageable
      * Be careful with that
      * Quote from http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1879.htm
        "properly determining whether a source value is in range for a given destination type is tricky
        because [that] involves comparing a value of a type with the boundary values of a different type,
        [a] task that itself requires a numeric conversion. This is in fact so difficult that
        boost::numeric_cast<> had it wrong for certain cases for years, even after a number of revisions"
      * Oh yeah.
        * So perhaps we do this simply for the 2 required conversions
          * unsigned long long => unsigned int
          * unsigned int => int
        * Problem is, if we implement some sort of e.g.:    int to_int(size_t s);
          Then we lose the ability to search for _cast and fix things later.
          Well, but then, nothing stops is from naming it e.g. to_int_cast. Muhahaha?
* Get it to compile with MSVC x64
  * Debug
  * Release
* Test debug/release build with
  * gcc 64
  * gcc 32
  * clang?
* Need a break from shrinkler:
  * Wrap up input file loading:
    * Optional flat binary loading (with the option to specify load address and entry point!)
      * Already implement the command line options
      * They are file format independent, so we just do:
        * Load file
        * If options override entry, set it on the input file
        * If options override load address, set it on the input file
    * Remaining sanity checks. Either:
      * Implement them
      * Defer them
      * Discard them
  * We might want to support binary as input file format, but probably this should be opt-in.
    * This means we expect ELF by default and fail if input file is not ELF.
    * Only load file as binary if requested to do so.
* Prepare shrinkler:
  * Put it into 3rdparty/shrinkler (orly? Perhaps we give it a top level directory since we are going to heavily hack it)
    * Is it going to get any tests?
  * Only include the packer sources
  * Include shrinkler's LICENSE.txt!
  * Include a README.md stating CLEARLY that this is NOT the original shrinkler
* Stop using submodules?
  * Just for real 3rd party modules. Keep it for our own, e.g. argp-standalone
  * Or use subtree everywhere:
    * Delete the cxxopts submodule
    * Add shrinkler as subtree
    * Add argp-standalone as subtree
* Design input file loading
  * Binary files, with an assumed load address of IWRAM (do we allow overriding this?)
  * Elf files, which we convert to raw binary and whose load address we determine from the entry point
* Remove cxxopts (including the submodule)
* Check: does our argp.h supersede system argp?
* Update copyright notice (Copyright (c) 2020 Thomas Mathys => 2020, 2021)
* For deploying windows binaries, do we need to take care to distribute runtime libraries? Or do we link statically?
* Eventually, get rid of the fmt library (yeah, right)
