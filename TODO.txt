* Need a break from shrinkler:
  * Next up is input file loading
  * Primary input file format is ELF, so should work on that.
  * We might want to support binary as input file format, but probably this should be opt-in.
    * This means we expect ELF by default and fail if input file is not ELF.
    * Only load file as binary if requested to do so.
  * Well, try out subtree.
* Prepare shrinkler:
  * OK: wrap shrinkler source into a library: we simply need it to do in memory compression of data files, I guess
    * How to we manage compiler flags? Shrinkler won't compile warning-free withour settings I am afraid
  * Put it into 3rdparty/shrinkler (orly? Perhaps we give it a top level directory since we are going to heavily hack it)
    * Try to create a header only library for it
    * Is it going to get any tests?
    * How MUCH are we going to hack it? I'd really not want it to call printf and exit all over the place
  * Only include the packer sources
  * Include shrinkler's LICENSE.txt!
  * Include a README.md stating CLEARLY that this is NOT the original shrinkler
* Stop using submodules?
  * Just for real 3rd party modules. Keep it for our own, e.g. argp-standalone
  * Or use subtree everywhere:
    * Delete the cxxopts submodule
    * Add shrinkler as subtree
    * Add argp-standalone as subtree
* Design input file loading
  * Binary files, with an assumed load address of IWRAM (do we allow overriding this?)
  * Elf files, which we convert to raw binary and whose load address we determine from the entry point
* Remove cxxopts (including the submodule)
* Check: does our argp.h supersede system argp?
* Update copyright notice (Copyright (c) 2020 Thomas Mathys => 2020, 2021)
* For deploying windows binaries, do we need to take care to distribute runtime libraries? Or do we link statically?
